Shiv Gohil, Binh Minh Nguyen, Nuoyan Wang, Andrew Zhao<br>
Carl Evans, Brad Solomon, Thierry Ramais<br>
CS 225<br>
12 December 2022<br>
# CS225 Final Project Report <br>
## Introduction <br>
Throughout the process of this project, we aimed to answer the fundamental question: Using a dataset of road intersections and edges and a dataset of airport locations, how can we best implement a “Shortest-Route Finder” using a graph data structure and algorithms? Ultimately, we represented intersections and airports as nodes in our graph, with road connections and air flights as the edges. Moreover, having decided on using California as our map area, we needed to complete the following stages: data cleaning and parsing, a graph implementation, as well as graph algorithms (BFS, Kruskal’s and A-star). 
## Data Cleaning: (getCleanedData.cpp)
First, we need to retrieve the data from our online datasets, and convert its format in the following way, keeping the pertinent information for our routeFinder application: 

>Nodes: (NodeID, transportType[0=road, 1=flight], name, longitude, latitude)<br>
>Edges: (EdgeID, transportType[0=road, 1=flight], startID, endID, direct-distance)

In this manner, we can later create weighted edges, where the weight is determined by distance multiplied by different factors for air and ground travel. Here, distance is the euclidean distance between two points, measured in units of “degrees of longitude-latitude.” We later omit the curvature of the Earth when converting from these degrees into units of miles or km as the distances between California are small enough that the curvature is small. <br>

Having decided on this format, we begin data cleaning within the “getCleanedData.cpp” file. Our function takes input filenames for the 3 datasets containing the California intersections, California road edges, and the World airports. For each of these three datasets, we iterate through the .dat file line by line, separating each line into vectors of strings depending on the comma-separated or space-separated nature of the original data file. As we iterate through, we need to omit erroneous data, such as duplicating edges, self-looping edges, as well as all non-commercial and non-California airports. The data we want within each individual line-by-line vector is then selected and output into output nodes.txt and edges.txt files, according to the formats in bold above. <br>

Now, our output nodes.txt file contains the road intersection and airport nodes, while our edges.txt file contains the road edges between select intersections. We still need to create flight edges between airports. To do this, we make the assumption that each of our selected airports has a flight to-and-from every other airport. We want to append these flights as edges in our output edges.txt files. To accomplish this, we need to add a portion of code within the airport data cleaning, allowing us to store a vector of just the airport nodes we want. Then, we simply use a nested for loop to create edges between every pair of airports, which are then appended to our edges.txt file as strings on each line.<br>

>Input and Output Text format visualized:<br>
![Input and Output Text format visualized](resultImages/sanitize_IO.png)

### KDTree:
In the final step of data cleaning, we want to append new road edges from each airport to the nearest intersection. In doing so, we complete our integration between the road network and the airport network, which allows us to seamlessly transition from driving to getting to an airport and taking a flight and vice versa. The best method that we figured out how to  accomplish our goals was by using the Kd-Tree that we created before in the “mp_mosiacs” assignment as we had already completed the findNearestNeighbor() function in said assignment. <br>

In our project, we made the entire process of finding and then creating these edges a separate function called connectGraphs() which takes in the index of the last edge created as an integer variable called currIdx and returns a vector of strings. This section of the code simply creates a vector of Points using the longitude and latitude of every intersection node and maps that Point to its node ID. We then call the Kd-tree constructor on that vector and loop through every single airport node; we can then use the longitude and latitude of the airport nodes to call findNearestNeighbor() and feed the result into our map. This returns us the ID of the closest intersection to said airport which can then be used to create an edge between the intersection and current airport with, ID = currIdx+1 type= 0 and weight=0 . The reason our weight is 0 is because the exact length is unknown, but should be small enough that is negligible and thus can be represented as a 0. This edge is then inserted into a vector of strings and currIdx is incremented for the next edge. When the loop completes, it simply returns the vector of all the edges to be used by the rest of the code which appends it to edges.txt. <br>

This current method is rather accurate, an example is shown below to prove this where allPoints is the airport location and mapLookup is the closest intersection with the points plotted on google maps:

>Airport to Closest Intersection Coordinates on Google Maps<br>
![Airport to Closest Intersection](resultImages/kdtree.png)
![Airport to Closest Intersection](resultImages/googleMaps.png)<br>

### Testing:
To test functionality for Data Cleaning, we implemented five test cases. The first test case just measures if the program created an edge from every airport to an intersection using the Kd-tree. The next two test cases are simple insertion cases of varying sizes that ensures that all of the relevant data are properly added from our files. However, the small test case only had Edge Data correction to remove any edges between non-existent nodes. The medium size test case not only has Edge Data correction but also Node Data Correction by removing invalid airport nodes. The fourth test case focuses more on eliminating on invalid edges such as self loops and duplicate edges and removing any airports that don't fit our required parameters. The last test case focuses on a larger dataset, where we test to make sure that the correct number of valid airports are included. We also test to make sure that there is indeed one flight connecting each pair of airports. Once all of these tests were passed we knew that our code would be able to correctly process the entire dataset. <br>

## Input Reading:
The next step in our assignment was to take all of the nodes and edges that were created by the Data Cleanup Algorithm and insert them into our graph. This part of the project was rather simple, it had one function called fullGraph which was a constructor for the fullGraph class. It took in a Graph reference and a vector of strings representing all the files a user may want to be inserted; however, the file order in the vector must go node, edge, node, edge, …. This was done so that if the user ever wished to have more than two types of travel types they could be easily inserted into the graph. For example, they could insert a plane, car, and train data type if they so wished to. The code first starts looping through the vector calling the helper function insertAllNodes and insertAllEdges which loops through the given file and inserts all the nodes and edges into the graph from the file. This is done by simply looping through the file one character at a time, and since we know what the data has been cleaned and what format should be, in that loop we can iterate through the line, converting each character either to an int or a double, and once we get all the info we insert it either as an edge or node and then we loop back until the file is empty. 

### Testing:
Since fileParser.cpp is a pretty simple algorithm that inserts all the nodes and edges from the file, there are only two test cases of varying sizes that checks if all of the nodes and edges contained in the file are properly added. The small test case just tests with a file of 3 nodes and a file with 1 edge and then checks if all were added. The 2nd test case is a massive one that uses all the nodes/edges created by our sanitized code and also just checks if all of them were properly added/detected by our code. Since they both pass, we know this aspect of the code works

## Algorithms:

### Kruskal's:

### Testing:

### A-star:
The A-star algorithm is a popular pathfinding algorithm that makes use of heuristics to look for the shortest path between nodes in a graph. The algorithm is defined in a*.cpp and under the function shortestPath. The function takes the graph to be used and starting and ending coordinates as parameters, and returns a vector of copied graph edges. To implement this function, a new data struct was defined in "a*.h" called Cell, a structure that contains a geographical location that's stored in a copied graph node, a pointer to its "parent" Cell which replicates a backwards linked list, and an F-score. How the A-star algorithm works and why it's unique from other traversals is that it intelligently looks for the next node in the shortest path by calculating the cost to move from the current node to the potential next node and summing that with the estimated cost of moving from the potential next node to the end with an approximation heuristic. For our approximation heuristic, we used the Euclidean distance between the potential next node and end node in miles divided by the average speed limit in America (55 mph) to get an estimate of the time it takes to get from that node to the end. The sum of this estimated cost and calculated cost is known as the F-score, and A-star always chooses the Cell with the smallest F-score to proceed. The algorithm also uses an open and closed list to know which Cells have already been processed and what Cells haven’t. Whenever the ending node is found, the path is generated by traversing through the backwards linked list in Cell->parent. Because the linked list stores the correct path in reverse order, we can simply flip the generated path of edges to get the path in correct order, which is what’s returned. In our implementation, we used a priority queue as the open list in order to optimize runtime and have the Cell with the smallest F-score always at the front of the queue, and we used a vector of booleans as the closed list, to tell us whether or not a node has already been visited so we know which Cells to skip when we are iterating through a Cell's neighbors. Cells are each allocated on heap memory so that their addresses stay permanent to make the linked list work, and when the ending node is found, they are deallocated before returning the answer. A-star is costly in regards to time as it runs in O(nlog(n)) time, since for every node that is checked all its adjacent nodes are checked again.

### Testing:
For testing, two test cases were written that covered a basic minimum spanning five node graph with two edge paths and a more complex six node graph with multiple paths between nodes and edges of different weights. I found it unnecessary to run A-star on edge cases of single node or empty graphs since it would be pointless to run A-star in those cases. The first test case ensured that A-star could do basic traversal and pathfinding as well as tested the KDtree implementation of being able to find the closest node to a generic pair of coordinates. The second test case tested the algorithm’s intelligence, testing that the algorithm would create the correct shortest path between nodes with multiple paths between them. We ran A-star on the custom graph of California without asserts as well, and it seemed to have correctly generated shortest paths between data points. 
